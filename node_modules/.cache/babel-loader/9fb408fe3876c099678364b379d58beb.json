{"ast":null,"code":"import * as anchor from '@project-serum/anchor';\nimport { MintLayout, TOKEN_PROGRAM_ID, Token } from '@solana/spl-token';\nimport { SystemProgram } from '@solana/web3.js';\nimport { sendTransactions } from './connection';\nimport { CIVIC, getAtaForMint, getNetworkExpire, getNetworkToken, SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID } from './utils';\nexport const CANDY_MACHINE_PROGRAM = new anchor.web3.PublicKey('cndy3Z4yapfJBmL3ShUp5exZKqR3z33thTzeNMm2gRZ');\nconst TOKEN_METADATA_PROGRAM_ID = new anchor.web3.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s');\nexport const awaitTransactionSignatureConfirmation = async function (txid, timeout, connection) {\n  let commitment = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'recent';\n  let queryStatus = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  let done = false;\n  let status = {\n    slot: 0,\n    confirmations: 0,\n    err: null\n  };\n  let subId = 0;\n  status = await new Promise(async (resolve, reject) => {\n    setTimeout(() => {\n      if (done) {\n        return;\n      }\n\n      done = true;\n      console.log('Rejecting for timeout...');\n      reject({\n        timeout: true\n      });\n    }, timeout);\n\n    while (!done && queryStatus) {\n      // eslint-disable-next-line no-loop-func\n      (async () => {\n        try {\n          const signatureStatuses = await connection.getSignatureStatuses([txid]);\n          status = signatureStatuses && signatureStatuses.value[0];\n\n          if (!done) {\n            if (!status) {\n              console.log('REST null result for', txid, status);\n            } else if (status.err) {\n              console.log('REST error for', txid, status);\n              done = true;\n              reject(status.err);\n            } else if (!status.confirmations) {\n              console.log('REST no confirmations for', txid, status);\n            } else {\n              console.log('REST confirmation for', txid, status);\n              done = true;\n              resolve(status);\n            }\n          }\n        } catch (e) {\n          if (!done) {\n            console.log('REST connection error: txid', txid, e);\n          }\n        }\n      })();\n\n      await sleep(2000);\n    }\n  }); //@ts-ignore\n\n  if (connection._signatureSubscriptions[subId]) {\n    connection.removeSignatureListener(subId);\n  }\n\n  done = true;\n  console.log('Returning status', status);\n  return status;\n};\n/* export */\n\nconst createAssociatedTokenAccountInstruction = (associatedTokenAddress, payer, walletAddress, splTokenMintAddress) => {\n  const keys = [{\n    pubkey: payer,\n    isSigner: true,\n    isWritable: true\n  }, {\n    pubkey: associatedTokenAddress,\n    isSigner: false,\n    isWritable: true\n  }, {\n    pubkey: walletAddress,\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: splTokenMintAddress,\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: anchor.web3.SystemProgram.programId,\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: TOKEN_PROGRAM_ID,\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: anchor.web3.SYSVAR_RENT_PUBKEY,\n    isSigner: false,\n    isWritable: false\n  }];\n  return new anchor.web3.TransactionInstruction({\n    keys,\n    programId: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n    data: Buffer.from([])\n  });\n};\n\nexport const getCandyMachineState = async (anchorWallet, candyMachineId, connection) => {\n  const provider = new anchor.Provider(connection, anchorWallet, {\n    preflightCommitment: 'recent'\n  });\n  const idl = await anchor.Program.fetchIdl(CANDY_MACHINE_PROGRAM, provider);\n  const program = new anchor.Program(idl, CANDY_MACHINE_PROGRAM, provider);\n  const state = await program.account.candyMachine.fetch(candyMachineId);\n  const itemsAvailable = state.data.itemsAvailable.toNumber();\n  const itemsRedeemed = state.itemsRedeemed.toNumber();\n  const itemsRemaining = itemsAvailable - itemsRedeemed;\n  return {\n    id: candyMachineId,\n    program,\n    state: {\n      itemsAvailable,\n      itemsRedeemed,\n      itemsRemaining,\n      isSoldOut: itemsRemaining === 0,\n      isActive: state.data.goLiveDate.toNumber() < new Date().getTime() / 1000 && (state.endSettings ? state.endSettings.endSettingType.date ? state.endSettings.number.toNumber() > new Date().getTime() / 1000 : itemsRedeemed < state.endSettings.number.toNumber() : true),\n      goLiveDate: state.data.goLiveDate,\n      treasury: state.wallet,\n      tokenMint: state.tokenMint,\n      gatekeeper: state.data.gatekeeper,\n      endSettings: state.data.endSettings,\n      whitelistMintSettings: state.data.whitelistMintSettings,\n      hiddenSettings: state.data.hiddenSettings,\n      price: state.data.price\n    }\n  };\n};\n\nconst getMasterEdition = async mint => {\n  return (await anchor.web3.PublicKey.findProgramAddress([Buffer.from('metadata'), TOKEN_METADATA_PROGRAM_ID.toBuffer(), mint.toBuffer(), Buffer.from('edition')], TOKEN_METADATA_PROGRAM_ID))[0];\n};\n\nconst getMetadata = async mint => {\n  return (await anchor.web3.PublicKey.findProgramAddress([Buffer.from('metadata'), TOKEN_METADATA_PROGRAM_ID.toBuffer(), mint.toBuffer()], TOKEN_METADATA_PROGRAM_ID))[0];\n};\n\nexport const getCandyMachineCreator = async candyMachine => {\n  return await anchor.web3.PublicKey.findProgramAddress([Buffer.from('candy_machine'), candyMachine.toBuffer()], CANDY_MACHINE_PROGRAM);\n};\nexport const mintOneToken = async (candyMachine, payer) => {\n  const mint = anchor.web3.Keypair.generate();\n  const userTokenAccountAddress = (await getAtaForMint(mint.publicKey, payer))[0];\n  const userPayingAccountAddress = candyMachine.state.tokenMint ? (await getAtaForMint(candyMachine.state.tokenMint, payer))[0] : payer;\n  const candyMachineAddress = candyMachine.id;\n  const remainingAccounts = [];\n  const signers = [mint];\n  const cleanupInstructions = [];\n  const instructions = [anchor.web3.SystemProgram.createAccount({\n    fromPubkey: payer,\n    newAccountPubkey: mint.publicKey,\n    space: MintLayout.span,\n    lamports: await candyMachine.program.provider.connection.getMinimumBalanceForRentExemption(MintLayout.span),\n    programId: TOKEN_PROGRAM_ID\n  }), Token.createInitMintInstruction(TOKEN_PROGRAM_ID, mint.publicKey, 0, payer, payer), createAssociatedTokenAccountInstruction(userTokenAccountAddress, payer, payer, mint.publicKey), Token.createMintToInstruction(TOKEN_PROGRAM_ID, mint.publicKey, userTokenAccountAddress, payer, [], 1)];\n\n  if (candyMachine.state.gatekeeper) {\n    remainingAccounts.push({\n      pubkey: (await getNetworkToken(payer, candyMachine.state.gatekeeper.gatekeeperNetwork))[0],\n      isWritable: true,\n      isSigner: false\n    });\n\n    if (candyMachine.state.gatekeeper.expireOnUse) {\n      remainingAccounts.push({\n        pubkey: CIVIC,\n        isWritable: false,\n        isSigner: false\n      });\n      remainingAccounts.push({\n        pubkey: (await getNetworkExpire(candyMachine.state.gatekeeper.gatekeeperNetwork))[0],\n        isWritable: false,\n        isSigner: false\n      });\n    }\n  }\n\n  if (candyMachine.state.whitelistMintSettings) {\n    const mint = new anchor.web3.PublicKey(candyMachine.state.whitelistMintSettings.mint);\n    const whitelistToken = (await getAtaForMint(mint, payer))[0];\n    remainingAccounts.push({\n      pubkey: whitelistToken,\n      isWritable: true,\n      isSigner: false\n    });\n\n    if (candyMachine.state.whitelistMintSettings.mode.burnEveryTime) {\n      const whitelistBurnAuthority = anchor.web3.Keypair.generate();\n      remainingAccounts.push({\n        pubkey: mint,\n        isWritable: true,\n        isSigner: false\n      });\n      remainingAccounts.push({\n        pubkey: whitelistBurnAuthority.publicKey,\n        isWritable: false,\n        isSigner: true\n      });\n      signers.push(whitelistBurnAuthority);\n      const exists = await candyMachine.program.provider.connection.getAccountInfo(whitelistToken);\n\n      if (exists) {\n        instructions.push(Token.createApproveInstruction(TOKEN_PROGRAM_ID, whitelistToken, whitelistBurnAuthority.publicKey, payer, [], 1));\n        cleanupInstructions.push(Token.createRevokeInstruction(TOKEN_PROGRAM_ID, whitelistToken, payer, []));\n      }\n    }\n  }\n\n  if (candyMachine.state.tokenMint) {\n    const transferAuthority = anchor.web3.Keypair.generate();\n    signers.push(transferAuthority);\n    remainingAccounts.push({\n      pubkey: userPayingAccountAddress,\n      isWritable: true,\n      isSigner: false\n    });\n    remainingAccounts.push({\n      pubkey: transferAuthority.publicKey,\n      isWritable: false,\n      isSigner: true\n    });\n    instructions.push(Token.createApproveInstruction(TOKEN_PROGRAM_ID, userPayingAccountAddress, transferAuthority.publicKey, payer, [], candyMachine.state.price.toNumber()));\n    cleanupInstructions.push(Token.createRevokeInstruction(TOKEN_PROGRAM_ID, userPayingAccountAddress, payer, []));\n  }\n\n  const metadataAddress = await getMetadata(mint.publicKey);\n  const masterEdition = await getMasterEdition(mint.publicKey);\n  const [candyMachineCreator, creatorBump] = await getCandyMachineCreator(candyMachineAddress);\n  instructions.push(await candyMachine.program.instruction.mintNft(creatorBump, {\n    accounts: {\n      candyMachine: candyMachineAddress,\n      candyMachineCreator,\n      payer: payer,\n      wallet: candyMachine.state.treasury,\n      mint: mint.publicKey,\n      metadata: metadataAddress,\n      masterEdition,\n      mintAuthority: payer,\n      updateAuthority: payer,\n      tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,\n      tokenProgram: TOKEN_PROGRAM_ID,\n      systemProgram: SystemProgram.programId,\n      rent: anchor.web3.SYSVAR_RENT_PUBKEY,\n      clock: anchor.web3.SYSVAR_CLOCK_PUBKEY,\n      recentBlockhashes: anchor.web3.SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n      instructionSysvarAccount: anchor.web3.SYSVAR_INSTRUCTIONS_PUBKEY\n    },\n    remainingAccounts: remainingAccounts.length > 0 ? remainingAccounts : undefined\n  }));\n\n  try {\n    return (await sendTransactions(candyMachine.program.provider.connection, candyMachine.program.provider.wallet, [instructions, cleanupInstructions], [signers, []])).txs.map(t => t.txid);\n  } catch (e) {\n    console.log(e);\n  }\n\n  return [];\n};\nexport const shortenAddress = function (address) {\n  let chars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;\n  return `${address.slice(0, chars)}...${address.slice(-chars)}`;\n};\n\nconst sleep = ms => {\n  return new Promise(resolve => setTimeout(resolve, ms));\n};","map":{"version":3,"sources":["D:/Solana/metaplex/metaplex-master/js/packages/fair-launch/src/candy-machine.ts"],"names":["anchor","MintLayout","TOKEN_PROGRAM_ID","Token","SystemProgram","sendTransactions","CIVIC","getAtaForMint","getNetworkExpire","getNetworkToken","SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID","CANDY_MACHINE_PROGRAM","web3","PublicKey","TOKEN_METADATA_PROGRAM_ID","awaitTransactionSignatureConfirmation","txid","timeout","connection","commitment","queryStatus","done","status","slot","confirmations","err","subId","Promise","resolve","reject","setTimeout","console","log","signatureStatuses","getSignatureStatuses","value","e","sleep","_signatureSubscriptions","removeSignatureListener","createAssociatedTokenAccountInstruction","associatedTokenAddress","payer","walletAddress","splTokenMintAddress","keys","pubkey","isSigner","isWritable","programId","SYSVAR_RENT_PUBKEY","TransactionInstruction","data","Buffer","from","getCandyMachineState","anchorWallet","candyMachineId","provider","Provider","preflightCommitment","idl","Program","fetchIdl","program","state","account","candyMachine","fetch","itemsAvailable","toNumber","itemsRedeemed","itemsRemaining","id","isSoldOut","isActive","goLiveDate","Date","getTime","endSettings","endSettingType","date","number","treasury","wallet","tokenMint","gatekeeper","whitelistMintSettings","hiddenSettings","price","getMasterEdition","mint","findProgramAddress","toBuffer","getMetadata","getCandyMachineCreator","mintOneToken","Keypair","generate","userTokenAccountAddress","publicKey","userPayingAccountAddress","candyMachineAddress","remainingAccounts","signers","cleanupInstructions","instructions","createAccount","fromPubkey","newAccountPubkey","space","span","lamports","getMinimumBalanceForRentExemption","createInitMintInstruction","createMintToInstruction","push","gatekeeperNetwork","expireOnUse","whitelistToken","mode","burnEveryTime","whitelistBurnAuthority","exists","getAccountInfo","createApproveInstruction","createRevokeInstruction","transferAuthority","metadataAddress","masterEdition","candyMachineCreator","creatorBump","instruction","mintNft","accounts","metadata","mintAuthority","updateAuthority","tokenMetadataProgram","tokenProgram","systemProgram","rent","clock","SYSVAR_CLOCK_PUBKEY","recentBlockhashes","SYSVAR_RECENT_BLOCKHASHES_PUBKEY","instructionSysvarAccount","SYSVAR_INSTRUCTIONS_PUBKEY","length","undefined","txs","map","t","shortenAddress","address","chars","slice","ms"],"mappings":"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","sourcesContent":["import * as anchor from '@project-serum/anchor';\n\nimport { MintLayout, TOKEN_PROGRAM_ID, Token } from '@solana/spl-token';\nimport { SystemProgram } from '@solana/web3.js';\nimport { sendTransactions } from './connection';\n\nimport {\n  CIVIC,\n  getAtaForMint,\n  getNetworkExpire,\n  getNetworkToken,\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n} from './utils';\n\nexport const CANDY_MACHINE_PROGRAM = new anchor.web3.PublicKey(\n  'cndy3Z4yapfJBmL3ShUp5exZKqR3z33thTzeNMm2gRZ',\n);\n\nconst TOKEN_METADATA_PROGRAM_ID = new anchor.web3.PublicKey(\n  'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s',\n);\n\ninterface CandyMachineState {\n  itemsAvailable: number;\n  itemsRedeemed: number;\n  itemsRemaining: number;\n  treasury: anchor.web3.PublicKey;\n  tokenMint: anchor.web3.PublicKey;\n  isSoldOut: boolean;\n  isActive: boolean;\n  goLiveDate: anchor.BN;\n  price: anchor.BN;\n  gatekeeper: null | {\n    expireOnUse: boolean;\n    gatekeeperNetwork: anchor.web3.PublicKey;\n  };\n  endSettings: null | [number, anchor.BN];\n  whitelistMintSettings: null | {\n    mode: any;\n    mint: anchor.web3.PublicKey;\n    presale: boolean;\n    discountPrice: null | anchor.BN;\n  };\n  hiddenSettings: null | {\n    name: string;\n    uri: string;\n    hash: Uint8Array;\n  };\n}\n\nexport interface CandyMachineAccount {\n  id: anchor.web3.PublicKey;\n  program: anchor.Program;\n  state: CandyMachineState;\n}\n\nexport const awaitTransactionSignatureConfirmation = async (\n  txid: anchor.web3.TransactionSignature,\n  timeout: number,\n  connection: anchor.web3.Connection,\n  commitment: anchor.web3.Commitment = 'recent',\n  queryStatus = false,\n): Promise<anchor.web3.SignatureStatus | null | void> => {\n  let done = false;\n  let status: anchor.web3.SignatureStatus | null | void = {\n    slot: 0,\n    confirmations: 0,\n    err: null,\n  };\n  let subId = 0;\n  status = await new Promise(async (resolve, reject) => {\n    setTimeout(() => {\n      if (done) {\n        return;\n      }\n      done = true;\n      console.log('Rejecting for timeout...');\n      reject({ timeout: true });\n    }, timeout);\n    while (!done && queryStatus) {\n      // eslint-disable-next-line no-loop-func\n      (async () => {\n        try {\n          const signatureStatuses = await connection.getSignatureStatuses([\n            txid,\n          ]);\n          status = signatureStatuses && signatureStatuses.value[0];\n          if (!done) {\n            if (!status) {\n              console.log('REST null result for', txid, status);\n            } else if (status.err) {\n              console.log('REST error for', txid, status);\n              done = true;\n              reject(status.err);\n            } else if (!status.confirmations) {\n              console.log('REST no confirmations for', txid, status);\n            } else {\n              console.log('REST confirmation for', txid, status);\n              done = true;\n              resolve(status);\n            }\n          }\n        } catch (e) {\n          if (!done) {\n            console.log('REST connection error: txid', txid, e);\n          }\n        }\n      })();\n      await sleep(2000);\n    }\n  });\n\n  //@ts-ignore\n  if (connection._signatureSubscriptions[subId]) {\n    connection.removeSignatureListener(subId);\n  }\n  done = true;\n  console.log('Returning status', status);\n  return status;\n};\n\n/* export */ const createAssociatedTokenAccountInstruction = (\n  associatedTokenAddress: anchor.web3.PublicKey,\n  payer: anchor.web3.PublicKey,\n  walletAddress: anchor.web3.PublicKey,\n  splTokenMintAddress: anchor.web3.PublicKey,\n) => {\n  const keys = [\n    { pubkey: payer, isSigner: true, isWritable: true },\n    { pubkey: associatedTokenAddress, isSigner: false, isWritable: true },\n    { pubkey: walletAddress, isSigner: false, isWritable: false },\n    { pubkey: splTokenMintAddress, isSigner: false, isWritable: false },\n    {\n      pubkey: anchor.web3.SystemProgram.programId,\n      isSigner: false,\n      isWritable: false,\n    },\n    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },\n    {\n      pubkey: anchor.web3.SYSVAR_RENT_PUBKEY,\n      isSigner: false,\n      isWritable: false,\n    },\n  ];\n  return new anchor.web3.TransactionInstruction({\n    keys,\n    programId: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n    data: Buffer.from([]),\n  });\n};\n\nexport const getCandyMachineState = async (\n  anchorWallet: anchor.Wallet,\n  candyMachineId: anchor.web3.PublicKey,\n  connection: anchor.web3.Connection,\n): Promise<CandyMachineAccount> => {\n  const provider = new anchor.Provider(connection, anchorWallet, {\n    preflightCommitment: 'recent',\n  });\n\n  const idl = await anchor.Program.fetchIdl(CANDY_MACHINE_PROGRAM, provider);\n\n  const program = new anchor.Program(idl, CANDY_MACHINE_PROGRAM, provider);\n\n  const state: any = await program.account.candyMachine.fetch(candyMachineId);\n  const itemsAvailable = state.data.itemsAvailable.toNumber();\n  const itemsRedeemed = state.itemsRedeemed.toNumber();\n  const itemsRemaining = itemsAvailable - itemsRedeemed;\n\n  return {\n    id: candyMachineId,\n    program,\n    state: {\n      itemsAvailable,\n      itemsRedeemed,\n      itemsRemaining,\n      isSoldOut: itemsRemaining === 0,\n      isActive:\n        state.data.goLiveDate.toNumber() < new Date().getTime() / 1000 &&\n        (state.endSettings\n          ? state.endSettings.endSettingType.date\n            ? state.endSettings.number.toNumber() > new Date().getTime() / 1000\n            : itemsRedeemed < state.endSettings.number.toNumber()\n          : true),\n      goLiveDate: state.data.goLiveDate,\n      treasury: state.wallet,\n      tokenMint: state.tokenMint,\n      gatekeeper: state.data.gatekeeper,\n      endSettings: state.data.endSettings,\n      whitelistMintSettings: state.data.whitelistMintSettings,\n      hiddenSettings: state.data.hiddenSettings,\n      price: state.data.price,\n    },\n  };\n};\n\nconst getMasterEdition = async (\n  mint: anchor.web3.PublicKey,\n): Promise<anchor.web3.PublicKey> => {\n  return (\n    await anchor.web3.PublicKey.findProgramAddress(\n      [\n        Buffer.from('metadata'),\n        TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n        mint.toBuffer(),\n        Buffer.from('edition'),\n      ],\n      TOKEN_METADATA_PROGRAM_ID,\n    )\n  )[0];\n};\n\nconst getMetadata = async (\n  mint: anchor.web3.PublicKey,\n): Promise<anchor.web3.PublicKey> => {\n  return (\n    await anchor.web3.PublicKey.findProgramAddress(\n      [\n        Buffer.from('metadata'),\n        TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n        mint.toBuffer(),\n      ],\n      TOKEN_METADATA_PROGRAM_ID,\n    )\n  )[0];\n};\n\nexport const getCandyMachineCreator = async (\n  candyMachine: anchor.web3.PublicKey,\n): Promise<[anchor.web3.PublicKey, number]> => {\n  return await anchor.web3.PublicKey.findProgramAddress(\n    [Buffer.from('candy_machine'), candyMachine.toBuffer()],\n    CANDY_MACHINE_PROGRAM,\n  );\n};\n\nexport const mintOneToken = async (\n  candyMachine: CandyMachineAccount,\n  payer: anchor.web3.PublicKey,\n): Promise<(string | undefined)[]> => {\n  const mint = anchor.web3.Keypair.generate();\n\n  const userTokenAccountAddress = (\n    await getAtaForMint(mint.publicKey, payer)\n  )[0];\n\n  const userPayingAccountAddress = candyMachine.state.tokenMint\n    ? (await getAtaForMint(candyMachine.state.tokenMint, payer))[0]\n    : payer;\n\n  const candyMachineAddress = candyMachine.id;\n  const remainingAccounts = [];\n  const signers: anchor.web3.Keypair[] = [mint];\n  const cleanupInstructions = [];\n  const instructions = [\n    anchor.web3.SystemProgram.createAccount({\n      fromPubkey: payer,\n      newAccountPubkey: mint.publicKey,\n      space: MintLayout.span,\n      lamports:\n        await candyMachine.program.provider.connection.getMinimumBalanceForRentExemption(\n          MintLayout.span,\n        ),\n      programId: TOKEN_PROGRAM_ID,\n    }),\n    Token.createInitMintInstruction(\n      TOKEN_PROGRAM_ID,\n      mint.publicKey,\n      0,\n      payer,\n      payer,\n    ),\n    createAssociatedTokenAccountInstruction(\n      userTokenAccountAddress,\n      payer,\n      payer,\n      mint.publicKey,\n    ),\n    Token.createMintToInstruction(\n      TOKEN_PROGRAM_ID,\n      mint.publicKey,\n      userTokenAccountAddress,\n      payer,\n      [],\n      1,\n    ),\n  ];\n\n  if (candyMachine.state.gatekeeper) {\n    remainingAccounts.push({\n      pubkey: (\n        await getNetworkToken(\n          payer,\n          candyMachine.state.gatekeeper.gatekeeperNetwork,\n        )\n      )[0],\n      isWritable: true,\n      isSigner: false,\n    });\n    if (candyMachine.state.gatekeeper.expireOnUse) {\n      remainingAccounts.push({\n        pubkey: CIVIC,\n        isWritable: false,\n        isSigner: false,\n      });\n      remainingAccounts.push({\n        pubkey: (\n          await getNetworkExpire(\n            candyMachine.state.gatekeeper.gatekeeperNetwork,\n          )\n        )[0],\n        isWritable: false,\n        isSigner: false,\n      });\n    }\n  }\n  if (candyMachine.state.whitelistMintSettings) {\n    const mint = new anchor.web3.PublicKey(\n      candyMachine.state.whitelistMintSettings.mint,\n    );\n\n    const whitelistToken = (await getAtaForMint(mint, payer))[0];\n    remainingAccounts.push({\n      pubkey: whitelistToken,\n      isWritable: true,\n      isSigner: false,\n    });\n\n    if (candyMachine.state.whitelistMintSettings.mode.burnEveryTime) {\n      const whitelistBurnAuthority = anchor.web3.Keypair.generate();\n\n      remainingAccounts.push({\n        pubkey: mint,\n        isWritable: true,\n        isSigner: false,\n      });\n      remainingAccounts.push({\n        pubkey: whitelistBurnAuthority.publicKey,\n        isWritable: false,\n        isSigner: true,\n      });\n      signers.push(whitelistBurnAuthority);\n      const exists =\n        await candyMachine.program.provider.connection.getAccountInfo(\n          whitelistToken,\n        );\n      if (exists) {\n        instructions.push(\n          Token.createApproveInstruction(\n            TOKEN_PROGRAM_ID,\n            whitelistToken,\n            whitelistBurnAuthority.publicKey,\n            payer,\n            [],\n            1,\n          ),\n        );\n        cleanupInstructions.push(\n          Token.createRevokeInstruction(\n            TOKEN_PROGRAM_ID,\n            whitelistToken,\n            payer,\n            [],\n          ),\n        );\n      }\n    }\n  }\n\n  if (candyMachine.state.tokenMint) {\n    const transferAuthority = anchor.web3.Keypair.generate();\n\n    signers.push(transferAuthority);\n    remainingAccounts.push({\n      pubkey: userPayingAccountAddress,\n      isWritable: true,\n      isSigner: false,\n    });\n    remainingAccounts.push({\n      pubkey: transferAuthority.publicKey,\n      isWritable: false,\n      isSigner: true,\n    });\n\n    instructions.push(\n      Token.createApproveInstruction(\n        TOKEN_PROGRAM_ID,\n        userPayingAccountAddress,\n        transferAuthority.publicKey,\n        payer,\n        [],\n        candyMachine.state.price.toNumber(),\n      ),\n    );\n    cleanupInstructions.push(\n      Token.createRevokeInstruction(\n        TOKEN_PROGRAM_ID,\n        userPayingAccountAddress,\n        payer,\n        [],\n      ),\n    );\n  }\n  const metadataAddress = await getMetadata(mint.publicKey);\n  const masterEdition = await getMasterEdition(mint.publicKey);\n\n  const [candyMachineCreator, creatorBump] = await getCandyMachineCreator(\n    candyMachineAddress,\n  );\n\n  instructions.push(\n    await candyMachine.program.instruction.mintNft(creatorBump, {\n      accounts: {\n        candyMachine: candyMachineAddress,\n        candyMachineCreator,\n        payer: payer,\n        wallet: candyMachine.state.treasury,\n        mint: mint.publicKey,\n        metadata: metadataAddress,\n        masterEdition,\n        mintAuthority: payer,\n        updateAuthority: payer,\n        tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,\n        tokenProgram: TOKEN_PROGRAM_ID,\n        systemProgram: SystemProgram.programId,\n        rent: anchor.web3.SYSVAR_RENT_PUBKEY,\n        clock: anchor.web3.SYSVAR_CLOCK_PUBKEY,\n        recentBlockhashes: anchor.web3.SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n        instructionSysvarAccount: anchor.web3.SYSVAR_INSTRUCTIONS_PUBKEY,\n      },\n      remainingAccounts:\n        remainingAccounts.length > 0 ? remainingAccounts : undefined,\n    }),\n  );\n\n  try {\n    return (\n      await sendTransactions(\n        candyMachine.program.provider.connection,\n        candyMachine.program.provider.wallet,\n        [instructions, cleanupInstructions],\n        [signers, []],\n      )\n    ).txs.map(t => t.txid);\n  } catch (e) {\n    console.log(e);\n  }\n\n  return [];\n};\n\nexport const shortenAddress = (address: string, chars = 4): string => {\n  return `${address.slice(0, chars)}...${address.slice(-chars)}`;\n};\n\nconst sleep = (ms: number): Promise<void> => {\n  return new Promise(resolve => setTimeout(resolve, ms));\n};\n"]},"metadata":{},"sourceType":"module"}